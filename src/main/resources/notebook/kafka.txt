kafka：是分布式发布-订阅消息系统。
	它最初由LinkedIn公司开发，之后成为Apache项目的一部分。
	Kafka是一种快速、可扩展的、设计内在就是分布式的，分区的和可复制的提交日志服务。
与传统消息系统的区别：
	设计是一个分布式系统，易于向外扩展
	同时为发布和订阅提供高吞吐量
	支持多订阅者，当失败时能够自动平衡消费者
	将消息持久化到磁盘，因此可用于批量消费
架构：
	话题（Topic）：特定类型的消息流
		消息是字节的有效负载（Payload）
		话题是消息的分类或种子（Feed）名								 Broker（Kafaka cluster）
	生产者（Producer）：发布消息到话题的任何对象							Producer    ++++	Consumer
	代理（Broker）：或称为（Kafaka集群），已发布的消息保存在一组服务器中				Producer ============》	Consumer
	消费者（Consumer）：可以订阅一个或多个话题，并从Broker拉数据，从而消费已发布的消息		Producer    ++++	Consumer
存储：
	话题的每个分区对应一个逻辑日志。物理上，一个日志为相同大小的一组分段文件。
	每次生产者发布消息到一个分区，代理就将消息追加到最后一个段文件中。
	当发布的消息数量达到设定值或者经过一定的时间后，段文件真正写入到磁盘中。
	写入完成之后，消息公开给消费者。

	Kafka系统中存储的消息没有明确的消息ID。
	消息通过日志中的偏移量来公开。（避免维护配套密集寻址，用于映射消息ID到实际消息地址的随机存取索引结构的开销）
	消息ID是增量的，但是不是连续的。要计算下一个消息的ID，可以在其逻辑偏移的基础上加上当前消息的长度

	消费者始终从特定分区顺序的获取消息，如果知道特定消息的偏移量，也就说明消费者已经消费了之前所有消息。
	消费者向代理发出异步请求，准备字节缓冲区用于消费。每个异步请求都包含要消费的消息偏移量。
	Kafka利用sendfile api高效的从代理的日志文件中分发字节给消费者
代理：
	kafka代理是无状态的。（意味着消费者必须维护已消费的状态信息）
	从代理删除消息变得很棘手，因为代理不知道消费者是否已经使用了该消息。
	Kafka创新性的解决了这个问题，它将一个简单的基于时间的SLA应用于保留策略。
	当消息在代理中超过一定的时间后，将会被自动删除。
	消费者可以故意回到老的偏移量再次消费数据